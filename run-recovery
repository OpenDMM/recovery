#!/bin/sh
#
# Copyright (C) 2014 Dream Property GmbH
#

set -e

BASE_URI=http://dreamboxupdate.com/download/recovery/dm7080/release
FILENAME=recovery
DEVICE=/dev/mmcblk0
DATA_PARTITION=${DEVICE}p2
DATA_MOUNTPOINT=/data
RECOVERY_CACHE=${DATA_MOUNTPOINT}/.recovery

HTMLESCAPE=cat
STDOUT=/dev/null
TEMP=
VERBOSE=1

is_blockdev()
{
	[ -b "${1}" ]
}

is_directory()
{
	[ -d "${1}" ]
}

is_file()
{
	[ -f "${1}" ]
}

is_readable()
{
	[ -r "${1}" ]
}

is_readable_file()
{
	is_file "${1}" && is_readable "${1}"
}

is_writeable()
{
	[ -w "${1}" ]
}

is_empty()
{
	[ -z "${1}" ]
}

is_initrd()
{
	is_file "/etc/initrd-release"
}

is_nfsroot()
{
	is_readable_file /proc/cmdline && grep -q -w root=/dev/nfs /proc/cmdline
}

is_mountpoint()
{
	mountpoint -q "${1}"
}

cleanup()
{
	is_empty "${TEMP}" || rm -rf "${TEMP}"
	unmount ${DATA_MOUNTPOINT}
}

abort()
{
	echo "Fatal: $@"
	exit 1
}

warn()
{
	echo "Warning: $@"
}

info()
{
	is_empty "${VERBOSE}" || echo "[*] $@"
}

prepare_workspace()
{
	umask 077

	TEMP=`mktemp -d` || abort 'Failed to create working directory'
	trap cleanup EXIT
	cd "${TEMP}" || abort 'Failed to change working directory'
}

fetch()
{
	info "Downloading '${1}/${2}'"
	wget -q "${1}/${2}" -O "${2}" >${STDOUT}
}

verify()
{
	info "Verifying signature of '${1}'"
	gpgv -q --ignore-time-conflict "${1}.sig" "${1}" 2>&1 | ${HTMLESCAPE} >${STDOUT}
}

fetch_signed()
{
	fetch "${1}" "${2}.sig" || true

	if [ -f "${RECOVERY_CACHE}/${2}" -a -f "${RECOVERY_CACHE}/${2}.sig" ]; then
		if [ ! -f "${2}.sig" ] || cmp -s "${2}.sig" "${RECOVERY_CACHE}/${2}.sig"; then
			info "Copying '${2}' from local storage"
			cp "${RECOVERY_CACHE}/${2}.sig" "${2}.sig"
			cp "${RECOVERY_CACHE}/${2}" "${2}"
		fi
	fi

	[ -f "${2}.sig" ] || abort "Failed to obtain signature '${2}.sig'"
	[ -f "${2}" ] && verify "${2}" || {
		fetch "${1}" "${2}" || abort "Failed to download '${2}'"
		verify "${2}" || abort 'Failed to verify signature'
	}
}

create_directory()
{
	mkdir -p "${1}" >${STDOUT}
}

unmount()
{
	if is_mountpoint "${1}"; then
		info "Unmounting '${1}'"
		umount "${1}" || mount -o remount,ro "${1}"
	fi
}

mount_cache()
{
	if is_blockdev "${DATA_PARTITION}"; then
		create_directory "${DATA_MOUNTPOINT}"
		if is_directory "${DATA_MOUNTPOINT}"; then
			info "Mounting '${DATA_MOUNTPOINT}' (ro)"
			mount -o ro "${DATA_PARTITION}" "${DATA_MOUNTPOINT}" || warn "Failed to mount data filesystem"
		fi
	fi
}

cache_changed()
{
	is_mountpoint "${DATA_MOUNTPOINT}" && ! cmp -s "${RECOVERY_CACHE}/${1}.sig" "${1}.sig"
}

remount_cache_rw()
{
	is_mountpoint "${DATA_MOUNTPOINT}" && info "Remounting '${DATA_MOUNTPOINT}' (rw)" && \
		mount -o remount,rw "${DATA_MOUNTPOINT}" && is_writeable "${DATA_MOUNTPOINT}"
}

update_cache()
{
	if cache_changed "${1}" && remount_cache_rw; then
		create_directory "${RECOVERY_CACHE}"
		if is_directory "${RECOVERY_CACHE}"; then
			info "Updating recovery cache"
			cp "${FILENAME}" "${RECOVERY_CACHE}/${FILENAME}" || true
			cp "${FILENAME}.sig" "${RECOVERY_CACHE}/${FILENAME}.sig" || true
		fi
	fi
}

unmount_cache()
{
	unmount "${DATA_MOUNTPOINT}"
}

run()
{
	local cmd="${1}"
	shift

	info "Running '${cmd}'"
	[ -z "$@" ] || info "Options '$@'"
	chmod 755 "${cmd}" || abort "Failed to set execute permissions"
	${cmd} $@ || abort "Failed to execute '${cmd}'"
}

usage()
{
	echo "Usage: ${0} [-ehqtv]"
	exit ${1}
}

SAVED_ARGV="$@"
while getopts ehqtv opt; do
	case "${opt}" in
		e)
			HTMLESCAPE="sed -e s,<,\&lt,g -e s,>,\&gt,g"
			;;
		q)
			VERBOSE=
			;;
		t)
			set -x
			;;
		v)
			STDOUT=/dev/stdout
			;;
		h|?)
			if [ "$opt" = "h" ]; then
				usage 0
			else
				usage 1
			fi
			;;
	esac
done

is_initrd || is_nfsroot || abort "This script may only run in recovery mode!"

prepare_workspace
export GNUPGHOME="${TEMP}"

(base64 -d > trustedkeys.gpg || abort 'Failed to write public key') << EOF
mQENBFPo2oUBCAC6dzqe5azBCkxzj99xNfzwB4L6tHzz83zqD2KUQuuJMhO7Q2g9AHnSNQ0z1+Bz
oX2gGX90FusBSLiCuZmNdnxlcl7KVfBe37EpYtQNGCZKlWeruCAUdJGKIyPJXDvkXCy3dj6z1ho8
p1r3uazEbUbJyLvwjzcg0Ua1qxFjLoq/h15yDgd0NCkMStL6gwKdmReLRfE/tn0K53CVQzIeEFyn
EW3N0tu2deiYkanHy/MM9IOIv3oQmoEWNaVsDf+gG7nUPj0QE66GOYlBugR5vNi3BorOctarQp/8
Dh56muiqomwwewJubzsvjUjpiYXdO/3RN2gOej2+5hUCiYmvOahfABEBAAG0LkRyZWFtYm94IERN
NzA4MCBSZWNvdmVyeSA8cmVjb3ZlcnlAZG03MDgwLmNvbT6JATgEEwECACIFAlPo2oUCGwMGCwkI
BwMCBhUIAgkKCwQWAgMBAh4BAheAAAoJEBWob67Wz1bnUGYH/0zmTS7Gtvv97oHHnz3JSkLybDRj
Jx/wH+vpzyCRl8rC7TlHs5GBfjoJ1Hjo4DsZqElTb8g+kg5WGzMBUUuwabRhZuf2CL7/IPKP+LWH
t2ByZX3OgS1Q+HDLob5wlKllD9y/wwekuwS/8cgdnDH9URHCBqIt5gWQzLU1pvmQrKPXM1aMsLQj
16vbktXNkREF/cNhWfQFQs2dOwmzNEDeuE32I6h7PYl1bFP0hCOmbkcTuibnC+tsWOJMKF1iZ8bq
xDND9BYTwGtD2SVrddu3i4kBz6hka01ZnfSUZewpu+TrCgaD6oENfarPiC9VYfKEFi10RIPIxwRX
s1tBOOQNKpywAgAD
EOF

mount_cache
fetch_signed "${BASE_URI}" "${FILENAME}"

update_cache "${FILENAME}"
unmount_cache

run "./${FILENAME}" "${SAVED_ARGV}"
